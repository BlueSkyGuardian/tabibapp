{"version":3,"sources":["../../../src/server/route-modules/route-module.ts"],"sourcesContent":["import type { IncomingMessage, ServerResponse } from 'node:http'\nimport type {\n  InstrumentationOnRequestError,\n  RequestErrorContext,\n} from '../instrumentation/types'\nimport type { ParsedUrlQuery } from 'node:querystring'\nimport type { UrlWithParsedQuery } from 'node:url'\nimport type {\n  PrerenderManifest,\n  RequiredServerFilesManifest,\n} from '../../build'\nimport type { DevRoutesManifest } from '../lib/router-utils/setup-dev-bundler'\nimport type { RouteDefinition } from '../route-definitions/route-definition'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport {\n  BUILD_ID_FILE,\n  BUILD_MANIFEST,\n  CLIENT_REFERENCE_MANIFEST,\n  NEXT_FONT_MANIFEST,\n  PRERENDER_MANIFEST,\n  REACT_LOADABLE_MANIFEST,\n  ROUTES_MANIFEST,\n  SERVER_FILES_MANIFEST,\n  SERVER_REFERENCE_MANIFEST,\n  SUBRESOURCE_INTEGRITY_MANIFEST,\n} from '../../shared/lib/constants'\nimport { parseReqUrl } from '../../lib/url'\nimport {\n  normalizeLocalePath,\n  type PathLocale,\n} from '../../shared/lib/i18n/normalize-locale-path'\nimport { isDynamicRoute } from '../../shared/lib/router/utils'\nimport { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix'\nimport { getServerUtils } from '../server-utils'\nimport { detectDomainLocale } from '../../shared/lib/i18n/detect-domain-locale'\nimport { getHostname } from '../../shared/lib/get-hostname'\nimport { checkIsOnDemandRevalidate } from '../api-utils'\nimport type { PreviewData } from '../../types'\nimport type { BuildManifest } from '../get-page-files'\nimport type { ReactLoadableManifest } from '../load-components'\nimport type { NextFontManifest } from '../../build/webpack/plugins/next-font-manifest-plugin'\nimport { normalizeDataPath } from '../../shared/lib/page-path/normalize-data-path'\nimport { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix'\nimport { addRequestMeta, getRequestMeta } from '../request-meta'\nimport { normalizePagePath } from '../../shared/lib/page-path/normalize-page-path'\nimport { isStaticMetadataRoute } from '../../lib/metadata/is-metadata-route'\nimport { IncrementalCache } from '../lib/incremental-cache'\nimport { initializeCacheHandlers, setCacheHandler } from '../use-cache/handlers'\nimport { interopDefault } from '../app-render/interop-default'\nimport type { RouteKind } from '../route-kind'\nimport type { NextConfigComplete } from '../config-shared'\nimport ResponseCache, { type ResponseGenerator } from '../response-cache'\nimport {\n  RouterServerContextSymbol,\n  routerServerGlobal,\n  type RouterServerContext,\n} from '../lib/router-utils/router-server-context'\n\n/**\n * RouteModuleOptions is the options that are passed to the route module, other\n * route modules should extend this class to add specific options for their\n * route.\n */\nexport interface RouteModuleOptions<\n  D extends RouteDefinition = RouteDefinition,\n  U = unknown,\n> {\n  readonly definition: Readonly<D>\n  readonly userland: Readonly<U>\n  readonly distDir: string\n  readonly projectDir: string\n}\n\n/**\n * RouteHandlerContext is the base context for a route handler.\n */\nexport interface RouteModuleHandleContext {\n  /**\n   * Any matched parameters for the request. This is only defined for dynamic\n   * routes.\n   */\n  params: Record<string, string | string[] | undefined> | undefined\n}\n\nconst dynamicImportEsmDefault = (id: string) =>\n  import(/* webpackIgnore: true */ /* turbopackIgnore: true */ id).then(\n    (mod) => mod.default || mod\n  )\n\n/**\n * RouteModule is the base class for all route modules. This class should be\n * extended by all route modules.\n */\nexport abstract class RouteModule<\n  D extends RouteDefinition = RouteDefinition,\n  U = unknown,\n> {\n  /**\n   * The userland module. This is the module that is exported from the user's\n   * code. This is marked as readonly to ensure that the module is not mutated\n   * because the module (when compiled) only provides getters.\n   */\n  public readonly userland: Readonly<U>\n\n  /**\n   * The definition of the route.\n   */\n  public readonly definition: Readonly<D>\n\n  /**\n   * The shared modules that are exposed and required for the route module.\n   */\n  public static readonly sharedModules: any\n\n  public isDev: boolean\n  public distDir: string\n  public projectDir: string\n  public isAppRouter?: boolean\n  public incrementCache?: IncrementalCache\n  public responseCache?: ResponseCache\n\n  constructor({\n    userland,\n    definition,\n    distDir,\n    projectDir,\n  }: RouteModuleOptions<D, U>) {\n    this.userland = userland\n    this.definition = definition\n    this.isDev = process.env.NODE_ENV === 'development'\n    this.distDir = distDir\n    this.projectDir = projectDir\n  }\n\n  public async instrumentationOnRequestError(\n    req: IncomingMessage,\n    ...args: Parameters<InstrumentationOnRequestError>\n  ) {\n    // this is only handled here for node, for edge it\n    // is handled in the adapter/loader instead\n    if (process.env.NEXT_RUNTIME !== 'edge') {\n      const { join } = require('node:path') as typeof import('node:path')\n      const absoluteProjectDir =\n        getRequestMeta(req, 'projectDir') ||\n        join(process.cwd(), this.projectDir)\n\n      const { instrumentationOnRequestError } = await import(\n        '../lib/router-utils/instrumentation-globals.external'\n      )\n\n      return instrumentationOnRequestError(\n        absoluteProjectDir,\n        this.distDir,\n        ...args\n      )\n    }\n  }\n\n  private loadManifests(projectDir: string, srcPage: string) {\n    if (process.env.NEXT_RUNTIME !== 'edge') {\n      const { loadManifestFromRelativePath } =\n        require('../load-manifest.external') as typeof import('../load-manifest.external')\n      const normalizedPagePath = normalizePagePath(srcPage)\n\n      const [\n        routesManifest,\n        prerenderManifest,\n        buildManifest,\n        reactLoadableManifest,\n        nextFontManifest,\n        clientReferenceManifest,\n        serverActionsManifest,\n        subresourceIntegrityManifest,\n        serverFilesManifest,\n        buildId,\n      ] = [\n        loadManifestFromRelativePath<DevRoutesManifest>({\n          projectDir,\n          distDir: this.distDir,\n          manifest: ROUTES_MANIFEST,\n          shouldCache: !this.isDev,\n        }),\n        loadManifestFromRelativePath<PrerenderManifest>({\n          projectDir,\n          distDir: this.distDir,\n          manifest: PRERENDER_MANIFEST,\n          shouldCache: !this.isDev,\n        }),\n        loadManifestFromRelativePath<BuildManifest>({\n          projectDir,\n          distDir: this.distDir,\n          manifest: BUILD_MANIFEST,\n          shouldCache: !this.isDev,\n        }),\n        loadManifestFromRelativePath<ReactLoadableManifest>({\n          projectDir,\n          distDir: this.distDir,\n          manifest: process.env.TURBOPACK\n            ? `server/${this.isAppRouter ? 'app' : 'pages'}${normalizedPagePath}/${REACT_LOADABLE_MANIFEST}`\n            : REACT_LOADABLE_MANIFEST,\n          handleMissing: true,\n          shouldCache: !this.isDev,\n        }),\n        loadManifestFromRelativePath<NextFontManifest>({\n          projectDir,\n          distDir: this.distDir,\n          manifest: `server/${NEXT_FONT_MANIFEST}.json`,\n          shouldCache: !this.isDev,\n        }),\n        this.isAppRouter && !isStaticMetadataRoute(srcPage)\n          ? loadManifestFromRelativePath({\n              distDir: this.distDir,\n              projectDir,\n              useEval: true,\n              handleMissing: true,\n              manifest: `server/app${srcPage.replace(/%5F/g, '_') + '_' + CLIENT_REFERENCE_MANIFEST}.js`,\n              shouldCache: !this.isDev,\n            })\n          : undefined,\n        this.isAppRouter\n          ? loadManifestFromRelativePath<any>({\n              distDir: this.distDir,\n              projectDir,\n              manifest: `server/${SERVER_REFERENCE_MANIFEST}.json`,\n              handleMissing: true,\n              shouldCache: !this.isDev,\n            })\n          : {},\n        loadManifestFromRelativePath<Record<string, string>>({\n          projectDir,\n          distDir: this.distDir,\n          manifest: `server/${SUBRESOURCE_INTEGRITY_MANIFEST}.json`,\n          handleMissing: true,\n          shouldCache: !this.isDev,\n        }),\n        this.isDev\n          ? ({} as any)\n          : loadManifestFromRelativePath<RequiredServerFilesManifest>({\n              projectDir,\n              distDir: this.distDir,\n              manifest: SERVER_FILES_MANIFEST,\n            }),\n        this.isDev\n          ? 'development'\n          : loadManifestFromRelativePath<any>({\n              projectDir,\n              distDir: this.distDir,\n              manifest: BUILD_ID_FILE,\n              skipParse: true,\n            }),\n      ]\n\n      return {\n        buildId,\n        buildManifest,\n        routesManifest,\n        nextFontManifest,\n        prerenderManifest,\n        serverFilesManifest,\n        reactLoadableManifest,\n        clientReferenceManifest: (clientReferenceManifest as any)\n          ?.__RSC_MANIFEST?.[srcPage.replace(/%5F/g, '_')],\n        serverActionsManifest,\n        subresourceIntegrityManifest,\n      }\n    }\n    throw new Error('Invariant: loadManifests called for edge runtime')\n  }\n\n  public async loadCustomCacheHandlers(\n    req: IncomingMessage,\n    nextConfig: NextConfigComplete\n  ) {\n    if (process.env.NEXT_RUNTIME !== 'edge') {\n      const { cacheHandlers } = nextConfig.experimental\n      if (!cacheHandlers) return\n\n      // If we've already initialized the cache handlers interface, don't do it\n      // again.\n      if (!initializeCacheHandlers()) return\n\n      for (const [kind, handler] of Object.entries(cacheHandlers)) {\n        if (!handler) continue\n\n        const { formatDynamicImportPath } =\n          require('../../lib/format-dynamic-import-path') as typeof import('../../lib/format-dynamic-import-path')\n\n        const { join } = require('node:path') as typeof import('node:path')\n        const absoluteProjectDir =\n          getRequestMeta(req, 'projectDir') ||\n          join(process.cwd(), this.projectDir)\n\n        setCacheHandler(\n          kind,\n          interopDefault(\n            await dynamicImportEsmDefault(\n              formatDynamicImportPath(\n                `${absoluteProjectDir}/${this.distDir}`,\n                handler\n              )\n            )\n          )\n        )\n      }\n    }\n  }\n\n  public async getIncrementalCache(\n    req: IncomingMessage,\n    nextConfig: NextConfigComplete,\n    prerenderManifest: DeepReadonly<PrerenderManifest>\n  ): Promise<IncrementalCache> {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      return (globalThis as any).__incrementalCache\n    } else {\n      let CacheHandler: any\n      const { cacheHandler } = nextConfig\n\n      if (cacheHandler) {\n        const { formatDynamicImportPath } =\n          require('../../lib/format-dynamic-import-path') as typeof import('../../lib/format-dynamic-import-path')\n\n        CacheHandler = interopDefault(\n          await dynamicImportEsmDefault(\n            formatDynamicImportPath(this.distDir, cacheHandler)\n          )\n        )\n      }\n      const { join } = require('node:path') as typeof import('node:path')\n      const projectDir =\n        getRequestMeta(req, 'projectDir') ||\n        join(process.cwd(), this.projectDir)\n\n      await this.loadCustomCacheHandlers(req, nextConfig)\n\n      // incremental-cache is request specific\n      // although can have shared caches in module scope\n      // per-cache handler\n      return new IncrementalCache({\n        fs: (\n          require('../lib/node-fs-methods') as typeof import('../lib/node-fs-methods')\n        ).nodeFs,\n        dev: this.isDev,\n        requestHeaders: req.headers,\n        allowedRevalidateHeaderKeys:\n          nextConfig.experimental.allowedRevalidateHeaderKeys,\n        minimalMode: getRequestMeta(req, 'minimalMode'),\n        serverDistDir: `${projectDir}/${this.distDir}/server`,\n        fetchCacheKeyPrefix: nextConfig.experimental.fetchCacheKeyPrefix,\n        maxMemoryCacheSize: nextConfig.cacheMaxMemorySize,\n        flushToDisk: nextConfig.experimental.isrFlushToDisk,\n        getPrerenderManifest: () => prerenderManifest,\n        CurCacheHandler: CacheHandler,\n      })\n    }\n  }\n\n  public async onRequestError(\n    req: IncomingMessage,\n    err: unknown,\n    errorContext: RequestErrorContext,\n    routerServerContext?: RouterServerContext[string]\n  ) {\n    if (routerServerContext?.logErrorWithOriginalStack) {\n      routerServerContext.logErrorWithOriginalStack(err, 'app-dir')\n    } else {\n      console.error(err)\n    }\n    await this.instrumentationOnRequestError(\n      req,\n      err,\n      {\n        path: req.url || '/',\n        headers: req.headers,\n        method: req.method || 'GET',\n      },\n      errorContext\n    )\n  }\n\n  public async prepare(\n    req: IncomingMessage,\n    res: ServerResponse,\n    {\n      srcPage,\n      multiZoneDraftMode,\n    }: {\n      srcPage: string\n      multiZoneDraftMode?: boolean\n    }\n  ): Promise<\n    | {\n        buildId: string\n        locale?: string\n        locales?: readonly string[]\n        defaultLocale?: string\n        query: ParsedUrlQuery\n        originalQuery: ParsedUrlQuery\n        originalPathname: string\n        params?: ParsedUrlQuery\n        parsedUrl: UrlWithParsedQuery\n        previewData: PreviewData\n        pageIsDynamic: boolean\n        isDraftMode: boolean\n        isNextDataRequest: boolean\n        buildManifest: DeepReadonly<BuildManifest>\n        nextFontManifest: DeepReadonly<NextFontManifest>\n        serverFilesManifest: DeepReadonly<RequiredServerFilesManifest>\n        reactLoadableManifest: DeepReadonly<ReactLoadableManifest>\n        routesManifest: DeepReadonly<DevRoutesManifest>\n        prerenderManifest: DeepReadonly<PrerenderManifest>\n        // we can't pull in the client reference type or it causes issues with\n        // our pre-compiled types\n        clientReferenceManifest?: any\n        serverActionsManifest?: any\n        subresourceIntegrityManifest?: DeepReadonly<Record<string, string>>\n        isOnDemandRevalidate: boolean\n        revalidateOnlyGenerated: boolean\n        nextConfig: NextConfigComplete\n        routerServerContext?: RouterServerContext[string]\n      }\n    | undefined\n  > {\n    // \"prepare\" is only needed for node runtime currently\n    // if we want to share the normalizing logic here\n    // we will need to allow passing in the i18n and similar info\n    if (process.env.NEXT_RUNTIME !== 'edge') {\n      const { join, relative } =\n        require('node:path') as typeof import('node:path')\n      const projectDir =\n        getRequestMeta(req, 'projectDir') ||\n        join(process.cwd(), this.projectDir)\n\n      const absoluteDistDir = getRequestMeta(req, 'distDir')\n\n      if (absoluteDistDir) {\n        this.distDir = relative(projectDir, absoluteDistDir)\n      }\n      const { ensureInstrumentationRegistered } = await import(\n        '../lib/router-utils/instrumentation-globals.external'\n      )\n      // ensure instrumentation is registered and pass\n      // onRequestError below\n      ensureInstrumentationRegistered(projectDir, this.distDir)\n\n      const manifests = await this.loadManifests(projectDir, srcPage)\n      const { routesManifest, prerenderManifest, serverFilesManifest } =\n        manifests\n\n      const { basePath, i18n, rewrites } = routesManifest\n\n      if (basePath) {\n        req.url = removePathPrefix(req.url || '/', basePath)\n      }\n\n      const parsedUrl = parseReqUrl(req.url || '/')\n      // if we couldn't parse the URL we can't continue\n      if (!parsedUrl) {\n        return\n      }\n      let isNextDataRequest = false\n\n      if (pathHasPrefix(parsedUrl.pathname || '/', '/_next/data')) {\n        isNextDataRequest = true\n        parsedUrl.pathname = normalizeDataPath(parsedUrl.pathname || '/')\n      }\n      let originalPathname = parsedUrl.pathname || '/'\n      const originalQuery = { ...parsedUrl.query }\n      const pageIsDynamic = isDynamicRoute(srcPage)\n\n      let localeResult: PathLocale | undefined\n      let detectedLocale: string | undefined\n\n      if (i18n) {\n        localeResult = normalizeLocalePath(\n          parsedUrl.pathname || '/',\n          i18n.locales\n        )\n\n        if (localeResult.detectedLocale) {\n          req.url = `${localeResult.pathname}${parsedUrl.search}`\n          originalPathname = localeResult.pathname\n\n          if (!detectedLocale) {\n            detectedLocale = localeResult.detectedLocale\n          }\n        }\n      }\n\n      const serverUtils = getServerUtils({\n        page: srcPage,\n        i18n,\n        basePath,\n        rewrites,\n        pageIsDynamic,\n        trailingSlash: process.env.__NEXT_TRAILING_SLASH as any as boolean,\n        caseSensitive: Boolean(routesManifest.caseSensitive),\n      })\n\n      const domainLocale = detectDomainLocale(\n        i18n?.domains,\n        getHostname(parsedUrl, req.headers),\n        detectedLocale\n      )\n      addRequestMeta(req, 'isLocaleDomain', Boolean(domainLocale))\n\n      const defaultLocale = domainLocale?.defaultLocale || i18n?.defaultLocale\n\n      // Ensure parsedUrl.pathname includes locale before processing\n      // rewrites or they won't match correctly.\n      if (defaultLocale && !detectedLocale) {\n        parsedUrl.pathname = `/${defaultLocale}${parsedUrl.pathname === '/' ? '' : parsedUrl.pathname}`\n      }\n      const locale =\n        getRequestMeta(req, 'locale') || detectedLocale || defaultLocale\n\n      const rewriteParamKeys = Object.keys(\n        serverUtils.handleRewrites(req, parsedUrl)\n      )\n\n      // after processing rewrites we want to remove locale\n      // from parsedUrl pathname\n      if (i18n) {\n        parsedUrl.pathname = normalizeLocalePath(\n          parsedUrl.pathname || '/',\n          i18n.locales\n        ).pathname\n      }\n\n      let params: Record<string, undefined | string | string[]> | undefined =\n        getRequestMeta(req, 'params')\n\n      // attempt parsing from pathname\n      if (!params && serverUtils.dynamicRouteMatcher) {\n        const paramsMatch = serverUtils.dynamicRouteMatcher(\n          normalizeDataPath(localeResult?.pathname || parsedUrl.pathname || '/')\n        )\n        const paramsResult = serverUtils.normalizeDynamicRouteParams(\n          paramsMatch || {},\n          true\n        )\n\n        if (paramsResult.hasValidParams) {\n          params = paramsResult.params\n        }\n      }\n\n      // Local \"next start\" expects the routing parsed query values\n      // to not be present in the URL although when deployed proxies\n      // will add query values from resolving the routes to pass to function.\n\n      // TODO: do we want to change expectations for \"next start\"\n      // to include these query values in the URL which affects asPath\n      // but would match deployed behavior, e.g. a rewrite from middleware\n      // that adds a query param would be in asPath as query but locally\n      // it won't be in the asPath but still available in the query object\n      const query = getRequestMeta(req, 'query') || {\n        ...parsedUrl.query,\n      }\n\n      const routeParamKeys = new Set<string>()\n      const combinedParamKeys = [...routeParamKeys]\n\n      for (const key of rewriteParamKeys) {\n        // We only want to filter rewrite param keys from the URL\n        // if they are matches from the URL e.g. the key/value matches\n        // before and after applying the rewrites /:path for /hello and\n        // { path: 'hello' } but not for { path: 'another' } and /hello\n        // TODO: we should prefix rewrite param keys the same as we do\n        // for dynamic routes so we can identify them properly\n        const originalValue = Array.isArray(originalQuery[key])\n          ? originalQuery[key].join('')\n          : originalQuery[key]\n\n        const queryValue = Array.isArray(query[key])\n          ? query[key].join('')\n          : query[key]\n\n        if (!(key in originalQuery) || originalValue === queryValue) {\n          combinedParamKeys.push(key)\n        }\n      }\n\n      serverUtils.normalizeCdnUrl(req, combinedParamKeys)\n      serverUtils.normalizeQueryParams(query, routeParamKeys)\n      serverUtils.filterInternalQuery(originalQuery, combinedParamKeys)\n\n      if (pageIsDynamic) {\n        const queryResult = serverUtils.normalizeDynamicRouteParams(query, true)\n\n        const paramsResult = serverUtils.normalizeDynamicRouteParams(\n          params || {},\n          true\n        )\n        const paramsToInterpolate: ParsedUrlQuery =\n          paramsResult.hasValidParams && params\n            ? params\n            : queryResult.hasValidParams\n              ? query\n              : {}\n\n        req.url = serverUtils.interpolateDynamicPath(\n          req.url || '/',\n          paramsToInterpolate\n        )\n        parsedUrl.pathname = serverUtils.interpolateDynamicPath(\n          parsedUrl.pathname || '/',\n          paramsToInterpolate\n        )\n        originalPathname = serverUtils.interpolateDynamicPath(\n          originalPathname,\n          paramsToInterpolate\n        )\n\n        // try pulling from query if valid\n        if (!params) {\n          if (queryResult.hasValidParams) {\n            params = Object.assign({}, queryResult.params)\n\n            // If we pulled from query remove it so it's\n            // only in params\n            for (const key in serverUtils.defaultRouteMatches) {\n              delete query[key]\n            }\n          } else {\n            // use final params from URL matching\n            const paramsMatch = serverUtils.dynamicRouteMatcher?.(\n              normalizeDataPath(\n                localeResult?.pathname || parsedUrl.pathname || '/'\n              )\n            )\n            // we don't normalize these as they are allowed to be\n            // the literal slug matches here e.g. /blog/[slug]\n            // actually being requested\n            if (paramsMatch) {\n              params = Object.assign({}, paramsMatch)\n            }\n          }\n        }\n      }\n\n      // Remove any normalized params from the query if they\n      // weren't present as non-prefixed query key e.g.\n      // ?search=1&nxtPsearch=hello we don't delete search\n      for (const key of routeParamKeys) {\n        if (!(key in originalQuery)) {\n          delete query[key]\n        }\n      }\n\n      const { isOnDemandRevalidate, revalidateOnlyGenerated } =\n        checkIsOnDemandRevalidate(req, prerenderManifest.preview)\n\n      let isDraftMode = false\n      let previewData: PreviewData\n\n      const { tryGetPreviewData } =\n        require('../api-utils/node/try-get-preview-data') as typeof import('../api-utils/node/try-get-preview-data')\n\n      previewData = tryGetPreviewData(\n        req,\n        res,\n        prerenderManifest.preview,\n        Boolean(multiZoneDraftMode)\n      )\n      isDraftMode = previewData !== false\n\n      const routerServerContext =\n        routerServerGlobal[RouterServerContextSymbol]?.[this.projectDir]\n      const nextConfig =\n        routerServerContext?.nextConfig || serverFilesManifest.config\n\n      return {\n        query,\n        originalQuery,\n        originalPathname,\n        params,\n        parsedUrl,\n        locale,\n        isNextDataRequest,\n        locales: i18n?.locales,\n        defaultLocale,\n        isDraftMode,\n        previewData,\n        pageIsDynamic,\n        isOnDemandRevalidate,\n        revalidateOnlyGenerated,\n        ...manifests,\n        serverActionsManifest: manifests.serverActionsManifest,\n        clientReferenceManifest: manifests.clientReferenceManifest,\n        nextConfig,\n        routerServerContext,\n      }\n    }\n  }\n\n  public getResponseCache(req: IncomingMessage) {\n    if (!this.responseCache) {\n      const minimalMode = getRequestMeta(req, 'minimalMode') ?? false\n      this.responseCache = new ResponseCache(minimalMode)\n    }\n    return this.responseCache\n  }\n\n  public async handleResponse({\n    req,\n    nextConfig,\n    cacheKey,\n    routeKind,\n    isFallback,\n    prerenderManifest,\n    isRoutePPREnabled,\n    isOnDemandRevalidate,\n    revalidateOnlyGenerated,\n    responseGenerator,\n    waitUntil,\n  }: {\n    req: IncomingMessage\n    nextConfig: NextConfigComplete\n    cacheKey: string | null\n    routeKind: RouteKind\n    isFallback?: boolean\n    prerenderManifest: DeepReadonly<PrerenderManifest>\n    isRoutePPREnabled?: boolean\n    isOnDemandRevalidate?: boolean\n    revalidateOnlyGenerated?: boolean\n    responseGenerator: ResponseGenerator\n    waitUntil?: (prom: Promise<any>) => void\n  }) {\n    const responseCache = this.getResponseCache(req)\n    const cacheEntry = await responseCache.get(cacheKey, responseGenerator, {\n      routeKind,\n      isFallback,\n      isRoutePPREnabled,\n      isOnDemandRevalidate,\n      isPrefetch: req.headers.purpose === 'prefetch',\n      incrementalCache: await this.getIncrementalCache(\n        req,\n        nextConfig,\n        prerenderManifest\n      ),\n      waitUntil,\n    })\n\n    if (!cacheEntry) {\n      if (\n        cacheKey &&\n        // revalidate only generated can bail even if cacheKey is provided\n        !(isOnDemandRevalidate && revalidateOnlyGenerated)\n      ) {\n        // A cache entry might not be generated if a response is written\n        // in `getInitialProps` or `getServerSideProps`, but those shouldn't\n        // have a cache key. If we do have a cache key but we don't end up\n        // with a cache entry, then either Next.js or the application has a\n        // bug that needs fixing.\n        throw new Error('invariant: cache entry required but not generated')\n      }\n    }\n    return cacheEntry\n  }\n}\n"],"names":["BUILD_ID_FILE","BUILD_MANIFEST","CLIENT_REFERENCE_MANIFEST","NEXT_FONT_MANIFEST","PRERENDER_MANIFEST","REACT_LOADABLE_MANIFEST","ROUTES_MANIFEST","SERVER_FILES_MANIFEST","SERVER_REFERENCE_MANIFEST","SUBRESOURCE_INTEGRITY_MANIFEST","parseReqUrl","normalizeLocalePath","isDynamicRoute","removePathPrefix","getServerUtils","detectDomainLocale","getHostname","checkIsOnDemandRevalidate","normalizeDataPath","pathHasPrefix","addRequestMeta","getRequestMeta","normalizePagePath","isStaticMetadataRoute","IncrementalCache","initializeCacheHandlers","setCacheHandler","interopDefault","ResponseCache","RouterServerContextSymbol","routerServerGlobal","dynamicImportEsmDefault","id","then","mod","default","RouteModule","constructor","userland","definition","distDir","projectDir","isDev","process","env","NODE_ENV","instrumentationOnRequestError","req","args","NEXT_RUNTIME","join","require","absoluteProjectDir","cwd","loadManifests","srcPage","loadManifestFromRelativePath","normalizedPagePath","routesManifest","prerenderManifest","buildManifest","reactLoadableManifest","nextFontManifest","clientReferenceManifest","serverActionsManifest","subresourceIntegrityManifest","serverFilesManifest","buildId","manifest","shouldCache","TURBOPACK","isAppRouter","handleMissing","useEval","replace","undefined","skipParse","__RSC_MANIFEST","Error","loadCustomCacheHandlers","nextConfig","cacheHandlers","experimental","kind","handler","Object","entries","formatDynamicImportPath","getIncrementalCache","globalThis","__incrementalCache","CacheHandler","cacheHandler","fs","nodeFs","dev","requestHeaders","headers","allowedRevalidateHeaderKeys","minimalMode","serverDistDir","fetchCacheKeyPrefix","maxMemoryCacheSize","cacheMaxMemorySize","flushToDisk","isrFlushToDisk","getPrerenderManifest","CurCacheHandler","onRequestError","err","errorContext","routerServerContext","logErrorWithOriginalStack","console","error","path","url","method","prepare","res","multiZoneDraftMode","relative","absoluteDistDir","ensureInstrumentationRegistered","manifests","basePath","i18n","rewrites","parsedUrl","isNextDataRequest","pathname","originalPathname","originalQuery","query","pageIsDynamic","localeResult","detectedLocale","locales","search","serverUtils","page","trailingSlash","__NEXT_TRAILING_SLASH","caseSensitive","Boolean","domainLocale","domains","defaultLocale","locale","rewriteParamKeys","keys","handleRewrites","params","dynamicRouteMatcher","paramsMatch","paramsResult","normalizeDynamicRouteParams","hasValidParams","routeParamKeys","Set","combinedParamKeys","key","originalValue","Array","isArray","queryValue","push","normalizeCdnUrl","normalizeQueryParams","filterInternalQuery","queryResult","paramsToInterpolate","interpolateDynamicPath","assign","defaultRouteMatches","isOnDemandRevalidate","revalidateOnlyGenerated","preview","isDraftMode","previewData","tryGetPreviewData","config","getResponseCache","responseCache","handleResponse","cacheKey","routeKind","isFallback","isRoutePPREnabled","responseGenerator","waitUntil","cacheEntry","get","isPrefetch","purpose","incrementalCache"],"mappings":"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","ignoreList":[0]}